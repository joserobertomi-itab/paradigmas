Projeto: Consumo Assíncrono, Processamento Paralelo e Agrupamento de Cidades com a GeoDB Cities API

Este projeto tem como objetivo principal a construção de uma aplicação computacional que integre, de forma coerente e tecnicamente fundamentada, conceitos de programação assíncrona, concorrência, paralelismo e programação funcional, aplicados a um cenário real de consumo e processamento de dados geográficos em larga escala, utilizando do algoritmo de agrupamento K-means. Para isso, será utilizada a GeoDB Cities API, acessada por meio da biblioteca wft-geodb-js-client , que disponibiliza informações reais e atualizadas sobre cidades ao redor do mundo, incluindo dados geográficos, demográficos e administrativos.  Siga as instruções de instalação no link fornecido. Não é necessário hospedar essa API, basta usar a versão disponível em https://rapidapi.com/wirefreethought/api/geodb-cities.  Faça o registro e obtenha um token de acesso.

Todo todo o sistema deverá adotar o paradigma de programação funcional, evitando estados globais mutáveis e efeitos colaterais explícitos, e privilegiando transformações de dados baseadas em composição de funções.

Na primeira etapa do projeto, o foco recai sobre o consumo assíncrono da API e sobre a construção de uma interface gráfica que permita ao usuário explorar um conjunto potencialmente grande de cidades. A aplicação deverá realizar chamadas ao endpoint GET /geo/cities (findCitiesUsingGET),  respeitando os mecanismos de paginação e ordenação oferecidos pela API. À medida que o usuário navega entre as páginas de resultados, novas requisições deverão ser disparadas de forma assíncrona, sem bloqueio da interface e sem recarregamento da página. 

A interface gráfica deverá apresentar dois espaços conceitualmente distintos. O primeiro será destinado à visualização dos resultados provenientes da API, exibindo as cidades retornadas em cada página de consulta. O segundo será reservado ao armazenamento das escolhas feitas pelo usuário, funcionando como um repositório temporário de cidades selecionadas para posterior análise. O usuário deverá ser capaz de selecionar cidades exibidas nos resultados e transferi-las para esse repositório local por meio de um botão, mantendo a aplicação responsiva durante todo o processo. Essa operação poderá ser repetida quantas vezes forem necessárias, sendo fundamental que o estado da aplicação seja preservado ao longo da navegação e das múltiplas requisições realizadas.

Concluída a etapa de exploração e seleção, a aplicação deverá evoluir para um cenário de processamento intensivo de dados. Para que o algoritmo de agrupamento produza resultados relevantes, será necessário trabalhar com um volume significativamente maior de cidades, em torno de 10 mil entradas. 

Após um click que um botão, deverá ser realizado o processo que preenchimento em memória deste conjunto de dados. A obtenção desse conjunto ampliado de dados deverá ser realizada de forma paralela, por meio do uso explícito de Web Workers. Cada worker será responsável por consultar subconjuntos distintos de páginas da API, (não pesquisar em sequência pois são ordenadas por país), permitindo que as requisições sejam distribuídas e executadas concorrentemente. Nesse contexto, os alunos deverão demonstrar consciência dos limites de taxa impostos pela API, adotando estratégias que evitem a saturação do serviço remoto ou o bloqueio de requisições.

O modelo de concorrência adotado deverá seguir princípios clássicos de sistemas paralelos, nos quais múltiplos agentes podem realizar leituras simultâneas, mas a escrita em estruturas compartilhadas deve ser cuidadosamente controlada. Para isso, a aplicação deverá utilizar memória compartilhada, implementando um algoritmo de divisão e conquista no qual cada worker processa sua parcela de dados de forma independente e devolve resultados parciais ao processo principal. 

Após finalizar o processo de preenchimento da memória compartilhada, inicia-se o processo de agrupamento automaticamente. Sobre esse conjunto de cidades, deverá ser implementado um algoritmo de agrupamento baseado no método k-means. O valor de k deverá ser fornecido pelo usuário. As métricas de similaridade utilizadas no agrupamento serão:  latitude, longitude, população. O algoritmo de k-means não poderá ser tratado como uma caixa-preta: sua implementação deverá ser explícita, paralelizada e estruturada de forma funcional, explorando os Web Workers para distribuir o cálculo das distâncias e a atualização dos centroides.

Ao final da execução do algoritmo, a aplicação deverá apresentar os agrupamentos gerados, permitindo ao usuário identificar quais cidades pertencem a cada cluster. 